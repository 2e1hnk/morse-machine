<!DOCTYPE html>
<html>
<head>
    <title>Decoding Morse Code With JavaScript</title>

    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/css/materialize.css">

    <style type="text/css">
        div.output {
        }
        div.output p.message {
            font-family: "courier new";
            font-size: 20px ;
            line-height: 30px ;
        }
        div.output span.possibleCharacters {
            background-color: gold ;
            display: inline-block ;
            padding: 0px 7px 0px 7px ;
        }
        div.alphabet {
            bottom: 0px ;
            position: fixed ;
        }
        div.alphabet h3 {
            margin: 0px 0px 20px 0px ;
        }
        div.alphabet ul.characters {
            margin: 0px 0px 0px 0px ;
            padding: 0px 0px 0px 0px ;
        }
        div.alphabet ul.characters li {
            border: 1px solid #CCCCCC ;
            display: inline-block ;
            padding: 10px 0px 10px 0px ;
            text-align: center ;
            width: 75px ;
        }
        div.alphabet ul.characters li span.character {
            display: block ;
            font-size: 14px ;
            line-height: 18px ;
            margin: 0px 0px 7px 0px ;
        }
        div.alphabet ul.characters li span.sequence {
            display: block ;
            font-size: 24px ;
            line-height: 18px ;
        }
    </style>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.4.js"></script>


    <script type="text/javascript">
        // Create a model for the Morse Code interpreter.
        var morseCode = (function(){
            // Define the desired note frequency in Hz
            this._freq = 440;
            // Define the desired code speed in words per minute
            // Note that code via a keeyboard is harder than with a key so this will probably be lower that normal key speed
            this._speed = 12;
            // Define the duration of the dot in milliseconds. Duration is calculated as 1200/speed (wpm)
            this._dotDuration = (1200 / this._speed);
            // Define the duration of the dash in milliseconds. The
            // dash is supposed to be 3x that of the dot.
            this._dashDuration = (this._dotDuration * 3);
            // Define the pause duration. This is the time between
            // letters and is supposed to be 1x that of the dot.
            this._pauseDuration = (this._dotDuration * 1);
            // Define the pattern map for the morse code patterns
            // as the relate the alpha-numeric characters that they
            // represent.
            this._patternMap = {
                "•⁃": "A",
                "⁃•••": "B",
                "⁃•⁃•": "C",
                "⁃••": "D",
                "•": "E",
                "••⁃•": "F",
                "⁃⁃•": "G",
                "••••": "H",
                "••": "I",
                "•⁃⁃⁃": "J",
                "⁃•⁃": "K",
                "•⁃••": "L",
                "⁃⁃": "M",
                "⁃•": "N",
                "⁃⁃⁃": "O",
                "•⁃⁃•": "P",
                "⁃⁃•⁃": "Q",
                "•⁃•": "R",
                "•••": "S",
                "⁃": "T",
                "••⁃": "U",
                "•••⁃": "V",
                "•⁃⁃": "W",
                "⁃••⁃": "X",
                "⁃•⁃⁃": "Y",
                "⁃⁃••": "Z",
                "⁃⁃⁃⁃⁃": "0",
                "•⁃⁃⁃⁃": "1",
                "••⁃⁃⁃": "2",
                "•••⁃⁃": "3",
                "••••⁃": "4",
                "•••••": "5",
                "⁃••••": "6",
                "⁃⁃•••": "7",
                "⁃⁃⁃••": "8",
                "⁃⁃⁃⁃•": "9",
                "•⁃•⁃•⁃": ".",
                "⁃⁃••⁃⁃": ",",
                "••⁃⁃••": "?",
                "•⁃⁃•⁃•": "@",
                "⁃••⁃•": "/",
                "⁃⁃⁃•••": ":",
                "•⁃⁃⁃⁃•": "'",
                "⁃••••⁃": "-",
                "⁃•••⁃": "=",
                "⁃•⁃⁃•": "(",
                "⁃•⁃⁃•⁃": ")",
                "•⁃••⁃•": '"',
                "•⁃•⁃•": "+",
                "⁃••⁃": "×",		// Multiplication
                "••••••••": "[err]",	// Error

            };
            // I am the current, transient sequence being evaluated.
            this._sequence = "";
            // ---------------------------------------------- //
            // ---------------------------------------------- //
            // I add the given value to the current sequence.
            //
            // Throws InvalidTone if not a dot or dash.
            this.addSequence = function( value ){
                // Check to make sure the value is valid.
                if (
                    (value !== "•") &&
                    (value !== "⁃")
                    ){
                    // Invalid value.
                    throw( new Error( "InvalidTone" ) );
                }
                // Add the given value to the end of the current
                // sequence value.
                this._sequence += value;
                // Return this object reference.
                return( this );
            };
            // I add a dash to the current sequence.
            this.dash = function(){
                // Reroute to the addSequence();
                return( this.addSequence( "⁃" ) );
            };
            // I add a dot to the current sequence.
            this.dot = function(){
                // Reroute to the addSequence();
                return( this.addSequence( "•" ) );
            };
            // I get the alpha-numeric character set as an array of
            // sequence-character pairs.
            this.getAlphabet = function(){
                // Create the empty set.
                var characterSet = [];
                // Loop over the patterns to map them to a character
                // set item.
                for (var pattern in this._patternMap){
                    // Push it onto the set.
                    characterSet.push({
                        sequence: pattern,
                        character: this._patternMap[ pattern ]
                    });
                }
                // Sort the character set alphabetically.
                characterSet.sort(
                    function( a, b ){
                        return( a.character <= b.character ? -1 : 1 );
                    }
                );
                // Return the character set.
                return( characterSet );
            };
            // I get the dash duration.
            this.getDashDuration = function(){
                return( this._dashDuration );
            };
            // I get the dot duration.
            this.getDotDuration = function(){
                return( this._dotDuration );
            };
            // I get the pause duration.
            this.getPauseDuration = function(){
                return( this._pauseDuration );
            };
            // I reset the current sequence.
            this.resetSequence = function(){
                // Clear the sequence.
                this._sequence = "";
            };
            // I get the possible character matches based on the
            // current sequence.
            this.resolvePartial = function(){
                // Create an array to hold our possible characters.
                var potentialCharacters = [];
                // Loop over the pattern match to find partial matches.
                for (var pattern in this._patternMap){
                    // Check to see if the current sequence can be
                    // the start of the given pattern.
                    if (pattern.indexOf( this._sequence ) === 0){
                        // Add this character to the list.
                        potentialCharacters.push(
                            this._patternMap[ pattern ]
                        );
                    }
                }
                // Return the potential character matches.
                return( potentialCharacters.sort() );
            };
            // I get the alpha-numeric charater repsented by the
            // current sequence. I also also reset the internal
            // sequence value.
            //
            // Throws InvalidSequence if it cannot be mapped to a
            // valid alpha-numeric character.
            this.resolveSequence = function(){
                // Check to see if the current sequence is valid.
                if (!this._patternMap.hasOwnProperty( this._sequence )){
                    // The sequence cannot be matched.
                    throw( new Error( "InvalidSequence" ) );
                }
                // Get the alpha-numeric mapping.
                var character = this._patternMap[ this._sequence ];
                // Reset the sequence.
                this._sequence = "";
                // Return the mapped character.
                return( character );
            };
            // ---------------------------------------------- //
            // ---------------------------------------------- //
            // Return this object reference.
            return( this );
        }).call( {} );
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body onLoad="updatePrefs()">

  <nav>
    <div class="nav-wrapper">
      <a href="#" class="brand-logo">MorseMachine</a>
    </div>
  </nav>

  <div class="container">
    <div class="row">
      <div class="col s12">
        <div class="controls">
	      <!--<input id="speed" type="range" min="5" max="30" step="1" onChange="updatePrefs()" value="12" />
          <span id="speedValue"></span>-->
          <input id="frequency" type="range" min="100" max="2000" step="1" onChange="updatePrefs()" value="440" />
          <span id="frequencyValue"></span>
        </div>
      </div>
    </div>

    <!-- BEGIN: Output. -->
    <div class="row">
      <div class="col s12">
        <div class="output">

          <h3>
            Your Message (Use any key as morse key):
          </h3>

          <p class="message">

            <span class="characters">
                <!-- This will be populated by the user. -->
            </span>

            <span class="possibleCharacters">
                <!-- This will be populated dynamically. -->
            </span>

          </p>
        </div>
      </div>
    </div>
    <!-- END: Output. -->

    <!-- BEGIN: Alphabet. -->
    <div class="row">
      <div class="col s12">
        <div class="alphabet">

          <h3>
            Morse Code Alphabet
          </h3>

          <div class="row characters">
            <!-- This will be populated dynamically. -->
          </div>

          <!-- Define the template. --->
          <script type="application/x-template" class="template">
              <div class="col s1">
                  <span class="character"></span>
                  <span class="sequence"></span>
              </div>
          </script>
        </div>
      </div>
    </div>
    <!-- END: Alphabet. -->

  </div>

    <script type="text/javascript">
        // Initialize the alphabet display.
        (function( $, container, morseCode ){
            // Get the dom elements in this module.
            var dom = {
                characters: container.find( "div.characters" ),
                template: container.find( "script.template" )
            };
            // Get the the alphabet from the morse code model.
            var alphabet = morseCode.getAlphabet();
            // Loop over the alphabet to build the output.
            for (var i = 0 ; i < alphabet.length ; i++){
                // Get the current letter short-hand.
                var letter = alphabet[ i ];
                // Create a new instance of the template.
                var template = $( dom.template.html() );
                // Set the character.
                template.find( "span.character" ).text(
                    letter.character
                );
                // Set the sequence.
                template.find( "span.sequence" ).text(
                    letter.sequence
                );
                // Add the template to the output.
                dom.characters.append( template );
            }
        })( jQuery, $( "div.alphabet" ), morseCode );
        // -------------------------------------------------- //
        // -------------------------------------------------- //
        // Initialize the interpreter.
        (function( $, container, morseCode ){
            // Get the dom elements in this module.
            var dom = {
                characters: container.find( "span.characters" ),
                possibleCharacters: container.find( "span.possibleCharacters" )
            };
            // Get the dot and dash durations (in milliseconds).
            var dotDuration = morseCode.getDotDuration();
            var dashDuration = morseCode.getDashDuration();
            var pauseDuration = morseCode.getPauseDuration();
            // Store the date/time for the keydown.
            var keyDownDate = null;
            // Keep a timer for post-key resolution for characters.
            var resolveTimer = null;
            // Keep a timer for adding a new space to the message.
            var spaceTimer = null;
            // For this module, we are going to bind to any key click
            // to indicate an interaction with the interpreter. There
            // will be no other key interaction.

            var audioContext = new AudioContext(), oscillator;

            $( document ).keydown(
                function( event ){
                    // Prevent any default action.
                    event.preventDefault();
                    // Check to see if there is a key-down date. If
                    // so, then exit - we only want the first press
                    // event to be registered.
                    if (keyDownDate){
                        // Don't process this event.
                        return;
                    }
                    // Clear the resolution timer.
                    clearTimeout( resolveTimer );
                    // Clear the space timer.
                    clearTimeout( spaceTimer );
                    // Store the date for this key-down.
                    keyDownDate = new Date();

                    oscillator = audioContext.createOscillator();
                    oscillator.type = "sine";
                    oscillator.frequency.value = morseCode._freq;
                    oscillator.connect(audioContext.destination);
                    oscillator.start();
                }
            );
            $( document ).keyup(
                function( event ){
                    // Prevent any default action.
                    event.preventDefault();

                    oscillator.stop();

                    // Determine the keypress duration.
                    var keyPressDuration = ((new Date())- keyDownDate);
                    // Clear the key down date so subsequent key
                    // press events can be processed.
                    keyDownDate = null;
                    // Check to see if the duration indicates a dot
                    // or a dash.
                    if (keyPressDuration <= dotDuration){
                        // Push a dot.
                        morseCode.dot();
                    } else {
                        // Push a dash.
                        morseCode.dash();
                    }
                    // Display the possible characters for the current
                    // sequence.
                    dom.possibleCharacters.text(
                        morseCode.resolvePartial().join( " , " )
                    );
                    // Now that the key has been pressed, we need to
                    // wait a bit to see if we need to resolve the
                    // current sequence (if the user doesn't interact
                    // with the interpreter, we'll resolve).
                    resolveTimer = setTimeout(
                        function(){
                            // Try to resolve the sequence.
                            try {
                                // Get the character respresented by
                                // the current sequence.
                                var character = morseCode.resolveSequence();
                                // Add it to the output.
                                dom.characters.text(
                                    dom.characters.text() + character
                                );
                                conn.send(character);
                            } catch (e) {
                                // Reset the sequence - something
                                // went wrong with the user's input.
                                morseCode.resetSequence();
                            }
                            // Clear the possible matches.
                            dom.possibleCharacters.empty();
                            // Set a timer to add a new space to the
                            // message.
                            spaceTimer = setTimeout(
                                function(){
                                    // Add a "space".
                                    dom.characters.text(
                                        dom.characters.text() + "⊠"
                                    );
                                },
                                3500
                            );
                        },
                        (pauseDuration * 3)
                    );
                }
            );
        })( jQuery, $( "div.output" ), morseCode );

        function updatePrefs() {

            //morseCode._speed = document.getElementById("speed").value;
            //document.getElementById("speedValue").innerHTML = morseCode._speed + " WPM";

            morseCode._freq = document.getElementById("frequency").value;
            document.getElementById("frequencyValue").innerHTML = morseCode._freq + " Hz";

            console.log(morseCode._speed + " WPM, " + morseCode._freq + " Hz");
        }

        function playString(str) {
          for (var i = 0, len = str.length; i < len; i++) {
            playChar(str[i]);
            sleepFor(morseCode._dotDuration * 3);
          }
        }

        function playChar(str) {
            for ( var key in morseCode._patternMap ) {
                if ( morseCode._patternMap[key] == str ) {
                   for (var i = 0, len = key.length; i < len; i++) {
                     if ( key[i] == "•" )
                     {
                       playDot();
                     }
                     else if ( key[i] == "⁃" )
                     {
                       playDash();
                     }
                     sleepFor(morseCode._dotDuration);
                   }                   
                }
            }
        }

        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        function sleepFor( sleepDuration ){
          var now = new Date().getTime();
          while(new Date().getTime() < now + sleepDuration){ /* do nothing */ } 
        }

        function playDot() {
          playTone(morseCode._dotDuration, morseCode._freq);
        }

        function playDash() {
          playTone(morseCode._dashDuration, morseCode._freq);
        }

        var audioContext = new AudioContext();

        function playTone(duration, frequency) {
          var oscillator = audioContext.createOscillator();
          oscillator.type = "sine";
          oscillator.frequency.value = frequency;
          oscillator.connect(audioContext.destination);
          oscillator.start();
          sleepFor(duration);
          oscillator.stop();
        }
        
        // Websocket stuff
		var conn = new WebSocket('ws://localhost:8080');
		conn.onopen = function(e) {
		    console.log("Websocket connection established!");
		};
		
		conn.onmessage = function(e) {
		    console.log(e.data);
		    playString(e.data);
		};
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/js/materialize.min.js"></script>

</body>
</html>